// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class AdminChanged extends ethereum.Event {
  get params(): AdminChanged__Params {
    return new AdminChanged__Params(this);
  }
}

export class AdminChanged__Params {
  _event: AdminChanged;

  constructor(event: AdminChanged) {
    this._event = event;
  }

  get previousAdmin(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newAdmin(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class BeaconUpgraded extends ethereum.Event {
  get params(): BeaconUpgraded__Params {
    return new BeaconUpgraded__Params(this);
  }
}

export class BeaconUpgraded__Params {
  _event: BeaconUpgraded;

  constructor(event: BeaconUpgraded) {
    this._event = event;
  }

  get beacon(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class BlockProposed extends ethereum.Event {
  get params(): BlockProposed__Params {
    return new BlockProposed__Params(this);
  }
}

export class BlockProposed__Params {
  _event: BlockProposed;

  constructor(event: BlockProposed) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get assignedProver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get livenessBond(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get meta(): BlockProposedMetaStruct {
    return changetype<BlockProposedMetaStruct>(
      this._event.parameters[3].value.toTuple(),
    );
  }

  get depositsProcessed(): Array<BlockProposedDepositsProcessedStruct> {
    return this._event.parameters[4].value.toTupleArray<BlockProposedDepositsProcessedStruct>();
  }
}

export class BlockProposedMetaStruct extends ethereum.Tuple {
  get l1Hash(): Bytes {
    return this[0].toBytes();
  }

  get difficulty(): Bytes {
    return this[1].toBytes();
  }

  get blobHash(): Bytes {
    return this[2].toBytes();
  }

  get extraData(): Bytes {
    return this[3].toBytes();
  }

  get depositsHash(): Bytes {
    return this[4].toBytes();
  }

  get coinbase(): Address {
    return this[5].toAddress();
  }

  get id(): BigInt {
    return this[6].toBigInt();
  }

  get gasLimit(): BigInt {
    return this[7].toBigInt();
  }

  get timestamp(): BigInt {
    return this[8].toBigInt();
  }

  get l1Height(): BigInt {
    return this[9].toBigInt();
  }

  get minTier(): i32 {
    return this[10].toI32();
  }

  get blobUsed(): boolean {
    return this[11].toBoolean();
  }

  get parentMetaHash(): Bytes {
    return this[12].toBytes();
  }

  get sender(): Address {
    return this[13].toAddress();
  }
}

export class BlockProposedDepositsProcessedStruct extends ethereum.Tuple {
  get recipient(): Address {
    return this[0].toAddress();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get id(): BigInt {
    return this[2].toBigInt();
  }
}

export class BlockProposed1 extends ethereum.Event {
  get params(): BlockProposed1__Params {
    return new BlockProposed1__Params(this);
  }
}

export class BlockProposed1__Params {
  _event: BlockProposed1;

  constructor(event: BlockProposed1) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get assignedProver(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get livenessBond(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get meta(): BlockProposed1MetaStruct {
    return changetype<BlockProposed1MetaStruct>(
      this._event.parameters[3].value.toTuple(),
    );
  }

  get depositsProcessed(): Array<BlockProposed1DepositsProcessedStruct> {
    return this._event.parameters[4].value.toTupleArray<BlockProposed1DepositsProcessedStruct>();
  }
}

export class BlockProposed1MetaStruct extends ethereum.Tuple {
  get l1Hash(): Bytes {
    return this[0].toBytes();
  }

  get difficulty(): Bytes {
    return this[1].toBytes();
  }

  get blobHash(): Bytes {
    return this[2].toBytes();
  }

  get extraData(): Bytes {
    return this[3].toBytes();
  }

  get depositsHash(): Bytes {
    return this[4].toBytes();
  }

  get coinbase(): Address {
    return this[5].toAddress();
  }

  get id(): BigInt {
    return this[6].toBigInt();
  }

  get gasLimit(): BigInt {
    return this[7].toBigInt();
  }

  get timestamp(): BigInt {
    return this[8].toBigInt();
  }

  get l1Height(): BigInt {
    return this[9].toBigInt();
  }

  get minTier(): i32 {
    return this[10].toI32();
  }

  get blobUsed(): boolean {
    return this[11].toBoolean();
  }

  get parentMetaHash(): Bytes {
    return this[12].toBytes();
  }

  get sender(): Address {
    return this[13].toAddress();
  }
}

export class BlockProposed1DepositsProcessedStruct extends ethereum.Tuple {
  get recipient(): Address {
    return this[0].toAddress();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get id(): BigInt {
    return this[2].toBigInt();
  }
}

export class BlockVerified extends ethereum.Event {
  get params(): BlockVerified__Params {
    return new BlockVerified__Params(this);
  }
}

export class BlockVerified__Params {
  _event: BlockVerified;

  constructor(event: BlockVerified) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get prover(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get blockHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get stateRoot(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }

  get tier(): i32 {
    return this._event.parameters[4].value.toI32();
  }
}

export class BlockVerified1 extends ethereum.Event {
  get params(): BlockVerified1__Params {
    return new BlockVerified1__Params(this);
  }
}

export class BlockVerified1__Params {
  _event: BlockVerified1;

  constructor(event: BlockVerified1) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get prover(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get blockHash(): Bytes {
    return this._event.parameters[2].value.toBytes();
  }

  get stateRoot(): Bytes {
    return this._event.parameters[3].value.toBytes();
  }

  get tier(): i32 {
    return this._event.parameters[4].value.toI32();
  }
}

export class Initialized extends ethereum.Event {
  get params(): Initialized__Params {
    return new Initialized__Params(this);
  }
}

export class Initialized__Params {
  _event: Initialized;

  constructor(event: Initialized) {
    this._event = event;
  }

  get version(): i32 {
    return this._event.parameters[0].value.toI32();
  }
}

export class OwnershipTransferStarted extends ethereum.Event {
  get params(): OwnershipTransferStarted__Params {
    return new OwnershipTransferStarted__Params(this);
  }
}

export class OwnershipTransferStarted__Params {
  _event: OwnershipTransferStarted;

  constructor(event: OwnershipTransferStarted) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Paused extends ethereum.Event {
  get params(): Paused__Params {
    return new Paused__Params(this);
  }
}

export class Paused__Params {
  _event: Paused;

  constructor(event: Paused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class ProvingPaused extends ethereum.Event {
  get params(): ProvingPaused__Params {
    return new ProvingPaused__Params(this);
  }
}

export class ProvingPaused__Params {
  _event: ProvingPaused;

  constructor(event: ProvingPaused) {
    this._event = event;
  }

  get paused(): boolean {
    return this._event.parameters[0].value.toBoolean();
  }
}

export class ProvingPaused1 extends ethereum.Event {
  get params(): ProvingPaused1__Params {
    return new ProvingPaused1__Params(this);
  }
}

export class ProvingPaused1__Params {
  _event: ProvingPaused1;

  constructor(event: ProvingPaused1) {
    this._event = event;
  }

  get paused(): boolean {
    return this._event.parameters[0].value.toBoolean();
  }
}

export class StateVariablesUpdated extends ethereum.Event {
  get params(): StateVariablesUpdated__Params {
    return new StateVariablesUpdated__Params(this);
  }
}

export class StateVariablesUpdated__Params {
  _event: StateVariablesUpdated;

  constructor(event: StateVariablesUpdated) {
    this._event = event;
  }

  get slotB(): StateVariablesUpdatedSlotBStruct {
    return changetype<StateVariablesUpdatedSlotBStruct>(
      this._event.parameters[0].value.toTuple(),
    );
  }
}

export class StateVariablesUpdatedSlotBStruct extends ethereum.Tuple {
  get numBlocks(): BigInt {
    return this[0].toBigInt();
  }

  get lastVerifiedBlockId(): BigInt {
    return this[1].toBigInt();
  }

  get provingPaused(): boolean {
    return this[2].toBoolean();
  }

  get __reservedB1(): i32 {
    return this[3].toI32();
  }

  get __reservedB2(): i32 {
    return this[4].toI32();
  }

  get __reservedB3(): BigInt {
    return this[5].toBigInt();
  }

  get lastUnpausedAt(): BigInt {
    return this[6].toBigInt();
  }
}

export class StateVariablesUpdated1 extends ethereum.Event {
  get params(): StateVariablesUpdated1__Params {
    return new StateVariablesUpdated1__Params(this);
  }
}

export class StateVariablesUpdated1__Params {
  _event: StateVariablesUpdated1;

  constructor(event: StateVariablesUpdated1) {
    this._event = event;
  }

  get slotB(): StateVariablesUpdated1SlotBStruct {
    return changetype<StateVariablesUpdated1SlotBStruct>(
      this._event.parameters[0].value.toTuple(),
    );
  }
}

export class StateVariablesUpdated1SlotBStruct extends ethereum.Tuple {
  get numBlocks(): BigInt {
    return this[0].toBigInt();
  }

  get lastVerifiedBlockId(): BigInt {
    return this[1].toBigInt();
  }

  get provingPaused(): boolean {
    return this[2].toBoolean();
  }

  get __reservedB1(): i32 {
    return this[3].toI32();
  }

  get __reservedB2(): i32 {
    return this[4].toI32();
  }

  get __reservedB3(): BigInt {
    return this[5].toBigInt();
  }

  get lastUnpausedAt(): BigInt {
    return this[6].toBigInt();
  }
}

export class TransitionContested extends ethereum.Event {
  get params(): TransitionContested__Params {
    return new TransitionContested__Params(this);
  }
}

export class TransitionContested__Params {
  _event: TransitionContested;

  constructor(event: TransitionContested) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tran(): TransitionContestedTranStruct {
    return changetype<TransitionContestedTranStruct>(
      this._event.parameters[1].value.toTuple(),
    );
  }

  get contester(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get contestBond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get tier(): i32 {
    return this._event.parameters[4].value.toI32();
  }
}

export class TransitionContestedTranStruct extends ethereum.Tuple {
  get parentHash(): Bytes {
    return this[0].toBytes();
  }

  get blockHash(): Bytes {
    return this[1].toBytes();
  }

  get stateRoot(): Bytes {
    return this[2].toBytes();
  }

  get graffiti(): Bytes {
    return this[3].toBytes();
  }
}

export class TransitionContested1 extends ethereum.Event {
  get params(): TransitionContested1__Params {
    return new TransitionContested1__Params(this);
  }
}

export class TransitionContested1__Params {
  _event: TransitionContested1;

  constructor(event: TransitionContested1) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tran(): TransitionContested1TranStruct {
    return changetype<TransitionContested1TranStruct>(
      this._event.parameters[1].value.toTuple(),
    );
  }

  get contester(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get contestBond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get tier(): i32 {
    return this._event.parameters[4].value.toI32();
  }
}

export class TransitionContested1TranStruct extends ethereum.Tuple {
  get parentHash(): Bytes {
    return this[0].toBytes();
  }

  get blockHash(): Bytes {
    return this[1].toBytes();
  }

  get stateRoot(): Bytes {
    return this[2].toBytes();
  }

  get graffiti(): Bytes {
    return this[3].toBytes();
  }
}

export class TransitionProved extends ethereum.Event {
  get params(): TransitionProved__Params {
    return new TransitionProved__Params(this);
  }
}

export class TransitionProved__Params {
  _event: TransitionProved;

  constructor(event: TransitionProved) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tran(): TransitionProvedTranStruct {
    return changetype<TransitionProvedTranStruct>(
      this._event.parameters[1].value.toTuple(),
    );
  }

  get prover(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get validityBond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get tier(): i32 {
    return this._event.parameters[4].value.toI32();
  }
}

export class TransitionProvedTranStruct extends ethereum.Tuple {
  get parentHash(): Bytes {
    return this[0].toBytes();
  }

  get blockHash(): Bytes {
    return this[1].toBytes();
  }

  get stateRoot(): Bytes {
    return this[2].toBytes();
  }

  get graffiti(): Bytes {
    return this[3].toBytes();
  }
}

export class TransitionProved1 extends ethereum.Event {
  get params(): TransitionProved1__Params {
    return new TransitionProved1__Params(this);
  }
}

export class TransitionProved1__Params {
  _event: TransitionProved1;

  constructor(event: TransitionProved1) {
    this._event = event;
  }

  get blockId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get tran(): TransitionProved1TranStruct {
    return changetype<TransitionProved1TranStruct>(
      this._event.parameters[1].value.toTuple(),
    );
  }

  get prover(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get validityBond(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get tier(): i32 {
    return this._event.parameters[4].value.toI32();
  }
}

export class TransitionProved1TranStruct extends ethereum.Tuple {
  get parentHash(): Bytes {
    return this[0].toBytes();
  }

  get blockHash(): Bytes {
    return this[1].toBytes();
  }

  get stateRoot(): Bytes {
    return this[2].toBytes();
  }

  get graffiti(): Bytes {
    return this[3].toBytes();
  }
}

export class Unpaused extends ethereum.Event {
  get params(): Unpaused__Params {
    return new Unpaused__Params(this);
  }
}

export class Unpaused__Params {
  _event: Unpaused;

  constructor(event: Unpaused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Upgraded extends ethereum.Event {
  get params(): Upgraded__Params {
    return new Upgraded__Params(this);
  }
}

export class Upgraded__Params {
  _event: Upgraded;

  constructor(event: Upgraded) {
    this._event = event;
  }

  get implementation(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class TaikoL1__getBlockResultBlk_Struct extends ethereum.Tuple {
  get metaHash(): Bytes {
    return this[0].toBytes();
  }

  get assignedProver(): Address {
    return this[1].toAddress();
  }

  get livenessBond(): BigInt {
    return this[2].toBigInt();
  }

  get blockId(): BigInt {
    return this[3].toBigInt();
  }

  get proposedAt(): BigInt {
    return this[4].toBigInt();
  }

  get proposedIn(): BigInt {
    return this[5].toBigInt();
  }

  get nextTransitionId(): BigInt {
    return this[6].toBigInt();
  }

  get verifiedTransitionId(): BigInt {
    return this[7].toBigInt();
  }
}

export class TaikoL1__getConfigResultValue0Struct extends ethereum.Tuple {
  get chainId(): BigInt {
    return this[0].toBigInt();
  }

  get blockMaxProposals(): BigInt {
    return this[1].toBigInt();
  }

  get blockRingBufferSize(): BigInt {
    return this[2].toBigInt();
  }

  get maxBlocksToVerifyPerProposal(): BigInt {
    return this[3].toBigInt();
  }

  get blockMaxGasLimit(): BigInt {
    return this[4].toBigInt();
  }

  get livenessBond(): BigInt {
    return this[5].toBigInt();
  }

  get blockSyncThreshold(): i32 {
    return this[6].toI32();
  }

  get checkEOAForCalldataDA(): boolean {
    return this[7].toBoolean();
  }
}

export class TaikoL1__getStateVariablesResultValue0Struct extends ethereum.Tuple {
  get genesisHeight(): BigInt {
    return this[0].toBigInt();
  }

  get genesisTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get lastSyncedBlockId(): BigInt {
    return this[2].toBigInt();
  }

  get lastSynecdAt(): BigInt {
    return this[3].toBigInt();
  }
}

export class TaikoL1__getStateVariablesResultValue1Struct extends ethereum.Tuple {
  get numBlocks(): BigInt {
    return this[0].toBigInt();
  }

  get lastVerifiedBlockId(): BigInt {
    return this[1].toBigInt();
  }

  get provingPaused(): boolean {
    return this[2].toBoolean();
  }

  get __reservedB1(): i32 {
    return this[3].toI32();
  }

  get __reservedB2(): i32 {
    return this[4].toI32();
  }

  get __reservedB3(): BigInt {
    return this[5].toBigInt();
  }

  get lastUnpausedAt(): BigInt {
    return this[6].toBigInt();
  }
}

export class TaikoL1__getStateVariablesResult {
  value0: TaikoL1__getStateVariablesResultValue0Struct;
  value1: TaikoL1__getStateVariablesResultValue1Struct;

  constructor(
    value0: TaikoL1__getStateVariablesResultValue0Struct,
    value1: TaikoL1__getStateVariablesResultValue1Struct,
  ) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromTuple(this.value0));
    map.set("value1", ethereum.Value.fromTuple(this.value1));
    return map;
  }

  getValue0(): TaikoL1__getStateVariablesResultValue0Struct {
    return this.value0;
  }

  getValue1(): TaikoL1__getStateVariablesResultValue1Struct {
    return this.value1;
  }
}

export class TaikoL1__getTransitionResultValue0Struct extends ethereum.Tuple {
  get key(): Bytes {
    return this[0].toBytes();
  }

  get blockHash(): Bytes {
    return this[1].toBytes();
  }

  get stateRoot(): Bytes {
    return this[2].toBytes();
  }

  get prover(): Address {
    return this[3].toAddress();
  }

  get validityBond(): BigInt {
    return this[4].toBigInt();
  }

  get contester(): Address {
    return this[5].toAddress();
  }

  get contestBond(): BigInt {
    return this[6].toBigInt();
  }

  get timestamp(): BigInt {
    return this[7].toBigInt();
  }

  get tier(): i32 {
    return this[8].toI32();
  }

  get __reserved1(): i32 {
    return this[9].toI32();
  }
}

export class TaikoL1__getTransition1ResultValue0Struct extends ethereum.Tuple {
  get key(): Bytes {
    return this[0].toBytes();
  }

  get blockHash(): Bytes {
    return this[1].toBytes();
  }

  get stateRoot(): Bytes {
    return this[2].toBytes();
  }

  get prover(): Address {
    return this[3].toAddress();
  }

  get validityBond(): BigInt {
    return this[4].toBigInt();
  }

  get contester(): Address {
    return this[5].toAddress();
  }

  get contestBond(): BigInt {
    return this[6].toBigInt();
  }

  get timestamp(): BigInt {
    return this[7].toBigInt();
  }

  get tier(): i32 {
    return this[8].toI32();
  }

  get __reserved1(): i32 {
    return this[9].toI32();
  }
}

export class TaikoL1__slotAResultValue0Struct extends ethereum.Tuple {
  get genesisHeight(): BigInt {
    return this[0].toBigInt();
  }

  get genesisTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get lastSyncedBlockId(): BigInt {
    return this[2].toBigInt();
  }

  get lastSynecdAt(): BigInt {
    return this[3].toBigInt();
  }
}

export class TaikoL1__slotBResultValue0Struct extends ethereum.Tuple {
  get numBlocks(): BigInt {
    return this[0].toBigInt();
  }

  get lastVerifiedBlockId(): BigInt {
    return this[1].toBigInt();
  }

  get provingPaused(): boolean {
    return this[2].toBoolean();
  }

  get __reservedB1(): i32 {
    return this[3].toI32();
  }

  get __reservedB2(): i32 {
    return this[4].toI32();
  }

  get __reservedB3(): BigInt {
    return this[5].toBigInt();
  }

  get lastUnpausedAt(): BigInt {
    return this[6].toBigInt();
  }
}

export class TaikoL1__stateResultSlotAStruct extends ethereum.Tuple {
  get genesisHeight(): BigInt {
    return this[0].toBigInt();
  }

  get genesisTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get lastSyncedBlockId(): BigInt {
    return this[2].toBigInt();
  }

  get lastSynecdAt(): BigInt {
    return this[3].toBigInt();
  }
}

export class TaikoL1__stateResultSlotBStruct extends ethereum.Tuple {
  get numBlocks(): BigInt {
    return this[0].toBigInt();
  }

  get lastVerifiedBlockId(): BigInt {
    return this[1].toBigInt();
  }

  get provingPaused(): boolean {
    return this[2].toBoolean();
  }

  get __reservedB1(): i32 {
    return this[3].toI32();
  }

  get __reservedB2(): i32 {
    return this[4].toI32();
  }

  get __reservedB3(): BigInt {
    return this[5].toBigInt();
  }

  get lastUnpausedAt(): BigInt {
    return this[6].toBigInt();
  }
}

export class TaikoL1__stateResult {
  value0: Bytes;
  value1: TaikoL1__stateResultSlotAStruct;
  value2: TaikoL1__stateResultSlotBStruct;

  constructor(
    value0: Bytes,
    value1: TaikoL1__stateResultSlotAStruct,
    value2: TaikoL1__stateResultSlotBStruct,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromTuple(this.value1));
    map.set("value2", ethereum.Value.fromTuple(this.value2));
    return map;
  }

  get__reserve1(): Bytes {
    return this.value0;
  }

  getSlotA(): TaikoL1__stateResultSlotAStruct {
    return this.value1;
  }

  getSlotB(): TaikoL1__stateResultSlotBStruct {
    return this.value2;
  }
}

export class TaikoL1 extends ethereum.SmartContract {
  static bind(address: Address): TaikoL1 {
    return new TaikoL1("TaikoL1", address);
  }

  addressManager(): Address {
    let result = super.call("addressManager", "addressManager():(address)", []);

    return result[0].toAddress();
  }

  try_addressManager(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "addressManager",
      "addressManager():(address)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getBlock(_blockId: BigInt): TaikoL1__getBlockResultBlk_Struct {
    let result = super.call(
      "getBlock",
      "getBlock(uint64):((bytes32,address,uint96,uint64,uint64,uint64,uint32,uint32))",
      [ethereum.Value.fromUnsignedBigInt(_blockId)],
    );

    return changetype<TaikoL1__getBlockResultBlk_Struct>(result[0].toTuple());
  }

  try_getBlock(
    _blockId: BigInt,
  ): ethereum.CallResult<TaikoL1__getBlockResultBlk_Struct> {
    let result = super.tryCall(
      "getBlock",
      "getBlock(uint64):((bytes32,address,uint96,uint64,uint64,uint64,uint32,uint32))",
      [ethereum.Value.fromUnsignedBigInt(_blockId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<TaikoL1__getBlockResultBlk_Struct>(value[0].toTuple()),
    );
  }

  getConfig(): TaikoL1__getConfigResultValue0Struct {
    let result = super.call(
      "getConfig",
      "getConfig():((uint64,uint64,uint64,uint64,uint32,uint96,uint8,bool))",
      [],
    );

    return changetype<TaikoL1__getConfigResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getConfig(): ethereum.CallResult<TaikoL1__getConfigResultValue0Struct> {
    let result = super.tryCall(
      "getConfig",
      "getConfig():((uint64,uint64,uint64,uint64,uint32,uint96,uint8,bool))",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<TaikoL1__getConfigResultValue0Struct>(value[0].toTuple()),
    );
  }

  getStateVariables(): TaikoL1__getStateVariablesResult {
    let result = super.call(
      "getStateVariables",
      "getStateVariables():((uint64,uint64,uint64,uint64),(uint64,uint64,bool,uint8,uint16,uint32,uint64))",
      [],
    );

    return changetype<TaikoL1__getStateVariablesResult>(
      new TaikoL1__getStateVariablesResult(
        changetype<TaikoL1__getStateVariablesResultValue0Struct>(
          result[0].toTuple(),
        ),
        changetype<TaikoL1__getStateVariablesResultValue1Struct>(
          result[1].toTuple(),
        ),
      ),
    );
  }

  try_getStateVariables(): ethereum.CallResult<TaikoL1__getStateVariablesResult> {
    let result = super.tryCall(
      "getStateVariables",
      "getStateVariables():((uint64,uint64,uint64,uint64),(uint64,uint64,bool,uint8,uint16,uint32,uint64))",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<TaikoL1__getStateVariablesResult>(
        new TaikoL1__getStateVariablesResult(
          changetype<TaikoL1__getStateVariablesResultValue0Struct>(
            value[0].toTuple(),
          ),
          changetype<TaikoL1__getStateVariablesResultValue1Struct>(
            value[1].toTuple(),
          ),
        ),
      ),
    );
  }

  getTransition(
    _blockId: BigInt,
    _tid: BigInt,
  ): TaikoL1__getTransitionResultValue0Struct {
    let result = super.call(
      "getTransition",
      "getTransition(uint64,uint32):((bytes32,bytes32,bytes32,address,uint96,address,uint96,uint64,uint16,uint8))",
      [
        ethereum.Value.fromUnsignedBigInt(_blockId),
        ethereum.Value.fromUnsignedBigInt(_tid),
      ],
    );

    return changetype<TaikoL1__getTransitionResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getTransition(
    _blockId: BigInt,
    _tid: BigInt,
  ): ethereum.CallResult<TaikoL1__getTransitionResultValue0Struct> {
    let result = super.tryCall(
      "getTransition",
      "getTransition(uint64,uint32):((bytes32,bytes32,bytes32,address,uint96,address,uint96,uint64,uint16,uint8))",
      [
        ethereum.Value.fromUnsignedBigInt(_blockId),
        ethereum.Value.fromUnsignedBigInt(_tid),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<TaikoL1__getTransitionResultValue0Struct>(value[0].toTuple()),
    );
  }

  getTransition1(
    _blockId: BigInt,
    _parentHash: Bytes,
  ): TaikoL1__getTransition1ResultValue0Struct {
    let result = super.call(
      "getTransition",
      "getTransition(uint64,bytes32):((bytes32,bytes32,bytes32,address,uint96,address,uint96,uint64,uint16,uint8))",
      [
        ethereum.Value.fromUnsignedBigInt(_blockId),
        ethereum.Value.fromFixedBytes(_parentHash),
      ],
    );

    return changetype<TaikoL1__getTransition1ResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getTransition1(
    _blockId: BigInt,
    _parentHash: Bytes,
  ): ethereum.CallResult<TaikoL1__getTransition1ResultValue0Struct> {
    let result = super.tryCall(
      "getTransition",
      "getTransition(uint64,bytes32):((bytes32,bytes32,bytes32,address,uint96,address,uint96,uint64,uint16,uint8))",
      [
        ethereum.Value.fromUnsignedBigInt(_blockId),
        ethereum.Value.fromFixedBytes(_parentHash),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<TaikoL1__getTransition1ResultValue0Struct>(value[0].toTuple()),
    );
  }

  impl(): Address {
    let result = super.call("impl", "impl():(address)", []);

    return result[0].toAddress();
  }

  try_impl(): ethereum.CallResult<Address> {
    let result = super.tryCall("impl", "impl():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  inNonReentrant(): boolean {
    let result = super.call("inNonReentrant", "inNonReentrant():(bool)", []);

    return result[0].toBoolean();
  }

  try_inNonReentrant(): ethereum.CallResult<boolean> {
    let result = super.tryCall("inNonReentrant", "inNonReentrant():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  lastUnpausedAt(): BigInt {
    let result = super.call("lastUnpausedAt", "lastUnpausedAt():(uint64)", []);

    return result[0].toBigInt();
  }

  try_lastUnpausedAt(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "lastUnpausedAt",
      "lastUnpausedAt():(uint64)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  paused(): boolean {
    let result = super.call("paused", "paused():(bool)", []);

    return result[0].toBoolean();
  }

  try_paused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("paused", "paused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  pendingOwner(): Address {
    let result = super.call("pendingOwner", "pendingOwner():(address)", []);

    return result[0].toAddress();
  }

  try_pendingOwner(): ethereum.CallResult<Address> {
    let result = super.tryCall("pendingOwner", "pendingOwner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  proxiableUUID(): Bytes {
    let result = super.call("proxiableUUID", "proxiableUUID():(bytes32)", []);

    return result[0].toBytes();
  }

  try_proxiableUUID(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      "proxiableUUID",
      "proxiableUUID():(bytes32)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  resolve(_chainId: BigInt, _name: Bytes, _allowZeroAddress: boolean): Address {
    let result = super.call(
      "resolve",
      "resolve(uint64,bytes32,bool):(address)",
      [
        ethereum.Value.fromUnsignedBigInt(_chainId),
        ethereum.Value.fromFixedBytes(_name),
        ethereum.Value.fromBoolean(_allowZeroAddress),
      ],
    );

    return result[0].toAddress();
  }

  try_resolve(
    _chainId: BigInt,
    _name: Bytes,
    _allowZeroAddress: boolean,
  ): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "resolve",
      "resolve(uint64,bytes32,bool):(address)",
      [
        ethereum.Value.fromUnsignedBigInt(_chainId),
        ethereum.Value.fromFixedBytes(_name),
        ethereum.Value.fromBoolean(_allowZeroAddress),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  resolve1(_name: Bytes, _allowZeroAddress: boolean): Address {
    let result = super.call("resolve", "resolve(bytes32,bool):(address)", [
      ethereum.Value.fromFixedBytes(_name),
      ethereum.Value.fromBoolean(_allowZeroAddress),
    ]);

    return result[0].toAddress();
  }

  try_resolve1(
    _name: Bytes,
    _allowZeroAddress: boolean,
  ): ethereum.CallResult<Address> {
    let result = super.tryCall("resolve", "resolve(bytes32,bool):(address)", [
      ethereum.Value.fromFixedBytes(_name),
      ethereum.Value.fromBoolean(_allowZeroAddress),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  slotA(): TaikoL1__slotAResultValue0Struct {
    let result = super.call(
      "slotA",
      "slotA():((uint64,uint64,uint64,uint64))",
      [],
    );

    return changetype<TaikoL1__slotAResultValue0Struct>(result[0].toTuple());
  }

  try_slotA(): ethereum.CallResult<TaikoL1__slotAResultValue0Struct> {
    let result = super.tryCall(
      "slotA",
      "slotA():((uint64,uint64,uint64,uint64))",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<TaikoL1__slotAResultValue0Struct>(value[0].toTuple()),
    );
  }

  slotB(): TaikoL1__slotBResultValue0Struct {
    let result = super.call(
      "slotB",
      "slotB():((uint64,uint64,bool,uint8,uint16,uint32,uint64))",
      [],
    );

    return changetype<TaikoL1__slotBResultValue0Struct>(result[0].toTuple());
  }

  try_slotB(): ethereum.CallResult<TaikoL1__slotBResultValue0Struct> {
    let result = super.tryCall(
      "slotB",
      "slotB():((uint64,uint64,bool,uint8,uint16,uint32,uint64))",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<TaikoL1__slotBResultValue0Struct>(value[0].toTuple()),
    );
  }

  state(): TaikoL1__stateResult {
    let result = super.call(
      "state",
      "state():(bytes32,(uint64,uint64,uint64,uint64),(uint64,uint64,bool,uint8,uint16,uint32,uint64))",
      [],
    );

    return new TaikoL1__stateResult(
      result[0].toBytes(),
      changetype<TaikoL1__stateResultSlotAStruct>(result[1].toTuple()),
      changetype<TaikoL1__stateResultSlotBStruct>(result[2].toTuple()),
    );
  }

  try_state(): ethereum.CallResult<TaikoL1__stateResult> {
    let result = super.tryCall(
      "state",
      "state():(bytes32,(uint64,uint64,uint64,uint64),(uint64,uint64,bool,uint8,uint16,uint32,uint64))",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new TaikoL1__stateResult(
        value[0].toBytes(),
        changetype<TaikoL1__stateResultSlotAStruct>(value[1].toTuple()),
        changetype<TaikoL1__stateResultSlotBStruct>(value[2].toTuple()),
      ),
    );
  }
}

export class AcceptOwnershipCall extends ethereum.Call {
  get inputs(): AcceptOwnershipCall__Inputs {
    return new AcceptOwnershipCall__Inputs(this);
  }

  get outputs(): AcceptOwnershipCall__Outputs {
    return new AcceptOwnershipCall__Outputs(this);
  }
}

export class AcceptOwnershipCall__Inputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class AcceptOwnershipCall__Outputs {
  _call: AcceptOwnershipCall;

  constructor(call: AcceptOwnershipCall) {
    this._call = call;
  }
}

export class InitCall extends ethereum.Call {
  get inputs(): InitCall__Inputs {
    return new InitCall__Inputs(this);
  }

  get outputs(): InitCall__Outputs {
    return new InitCall__Outputs(this);
  }
}

export class InitCall__Inputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _addressManager(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _genesisBlockHash(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get _toPause(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class InitCall__Outputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }
}

export class Init2Call extends ethereum.Call {
  get inputs(): Init2Call__Inputs {
    return new Init2Call__Inputs(this);
  }

  get outputs(): Init2Call__Outputs {
    return new Init2Call__Outputs(this);
  }
}

export class Init2Call__Inputs {
  _call: Init2Call;

  constructor(call: Init2Call) {
    this._call = call;
  }
}

export class Init2Call__Outputs {
  _call: Init2Call;

  constructor(call: Init2Call) {
    this._call = call;
  }
}

export class PauseCall extends ethereum.Call {
  get inputs(): PauseCall__Inputs {
    return new PauseCall__Inputs(this);
  }

  get outputs(): PauseCall__Outputs {
    return new PauseCall__Outputs(this);
  }
}

export class PauseCall__Inputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class PauseCall__Outputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class PauseProvingCall extends ethereum.Call {
  get inputs(): PauseProvingCall__Inputs {
    return new PauseProvingCall__Inputs(this);
  }

  get outputs(): PauseProvingCall__Outputs {
    return new PauseProvingCall__Outputs(this);
  }
}

export class PauseProvingCall__Inputs {
  _call: PauseProvingCall;

  constructor(call: PauseProvingCall) {
    this._call = call;
  }

  get _pause(): boolean {
    return this._call.inputValues[0].value.toBoolean();
  }
}

export class PauseProvingCall__Outputs {
  _call: PauseProvingCall;

  constructor(call: PauseProvingCall) {
    this._call = call;
  }
}

export class ProposeBlockCall extends ethereum.Call {
  get inputs(): ProposeBlockCall__Inputs {
    return new ProposeBlockCall__Inputs(this);
  }

  get outputs(): ProposeBlockCall__Outputs {
    return new ProposeBlockCall__Outputs(this);
  }
}

export class ProposeBlockCall__Inputs {
  _call: ProposeBlockCall;

  constructor(call: ProposeBlockCall) {
    this._call = call;
  }

  get _params(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get _txList(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class ProposeBlockCall__Outputs {
  _call: ProposeBlockCall;

  constructor(call: ProposeBlockCall) {
    this._call = call;
  }

  get meta_(): ProposeBlockCallMeta_Struct {
    return changetype<ProposeBlockCallMeta_Struct>(
      this._call.outputValues[0].value.toTuple(),
    );
  }

  get deposits_(): Array<ProposeBlockCallDeposits_Struct> {
    return this._call.outputValues[1].value.toTupleArray<ProposeBlockCallDeposits_Struct>();
  }
}

export class ProposeBlockCallMeta_Struct extends ethereum.Tuple {
  get l1Hash(): Bytes {
    return this[0].toBytes();
  }

  get difficulty(): Bytes {
    return this[1].toBytes();
  }

  get blobHash(): Bytes {
    return this[2].toBytes();
  }

  get extraData(): Bytes {
    return this[3].toBytes();
  }

  get depositsHash(): Bytes {
    return this[4].toBytes();
  }

  get coinbase(): Address {
    return this[5].toAddress();
  }

  get id(): BigInt {
    return this[6].toBigInt();
  }

  get gasLimit(): BigInt {
    return this[7].toBigInt();
  }

  get timestamp(): BigInt {
    return this[8].toBigInt();
  }

  get l1Height(): BigInt {
    return this[9].toBigInt();
  }

  get minTier(): i32 {
    return this[10].toI32();
  }

  get blobUsed(): boolean {
    return this[11].toBoolean();
  }

  get parentMetaHash(): Bytes {
    return this[12].toBytes();
  }

  get sender(): Address {
    return this[13].toAddress();
  }
}

export class ProposeBlockCallDeposits_Struct extends ethereum.Tuple {
  get recipient(): Address {
    return this[0].toAddress();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get id(): BigInt {
    return this[2].toBigInt();
  }
}

export class ProveBlockCall extends ethereum.Call {
  get inputs(): ProveBlockCall__Inputs {
    return new ProveBlockCall__Inputs(this);
  }

  get outputs(): ProveBlockCall__Outputs {
    return new ProveBlockCall__Outputs(this);
  }
}

export class ProveBlockCall__Inputs {
  _call: ProveBlockCall;

  constructor(call: ProveBlockCall) {
    this._call = call;
  }

  get _blockId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get _input(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class ProveBlockCall__Outputs {
  _call: ProveBlockCall;

  constructor(call: ProveBlockCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class ResetGenesisHashCall extends ethereum.Call {
  get inputs(): ResetGenesisHashCall__Inputs {
    return new ResetGenesisHashCall__Inputs(this);
  }

  get outputs(): ResetGenesisHashCall__Outputs {
    return new ResetGenesisHashCall__Outputs(this);
  }
}

export class ResetGenesisHashCall__Inputs {
  _call: ResetGenesisHashCall;

  constructor(call: ResetGenesisHashCall) {
    this._call = call;
  }

  get _genesisBlockHash(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }
}

export class ResetGenesisHashCall__Outputs {
  _call: ResetGenesisHashCall;

  constructor(call: ResetGenesisHashCall) {
    this._call = call;
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class UnpauseCall extends ethereum.Call {
  get inputs(): UnpauseCall__Inputs {
    return new UnpauseCall__Inputs(this);
  }

  get outputs(): UnpauseCall__Outputs {
    return new UnpauseCall__Outputs(this);
  }
}

export class UnpauseCall__Inputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UnpauseCall__Outputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UpgradeToCall extends ethereum.Call {
  get inputs(): UpgradeToCall__Inputs {
    return new UpgradeToCall__Inputs(this);
  }

  get outputs(): UpgradeToCall__Outputs {
    return new UpgradeToCall__Outputs(this);
  }
}

export class UpgradeToCall__Inputs {
  _call: UpgradeToCall;

  constructor(call: UpgradeToCall) {
    this._call = call;
  }

  get newImplementation(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UpgradeToCall__Outputs {
  _call: UpgradeToCall;

  constructor(call: UpgradeToCall) {
    this._call = call;
  }
}

export class UpgradeToAndCallCall extends ethereum.Call {
  get inputs(): UpgradeToAndCallCall__Inputs {
    return new UpgradeToAndCallCall__Inputs(this);
  }

  get outputs(): UpgradeToAndCallCall__Outputs {
    return new UpgradeToAndCallCall__Outputs(this);
  }
}

export class UpgradeToAndCallCall__Inputs {
  _call: UpgradeToAndCallCall;

  constructor(call: UpgradeToAndCallCall) {
    this._call = call;
  }

  get newImplementation(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get data(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class UpgradeToAndCallCall__Outputs {
  _call: UpgradeToAndCallCall;

  constructor(call: UpgradeToAndCallCall) {
    this._call = call;
  }
}

export class VerifyBlocksCall extends ethereum.Call {
  get inputs(): VerifyBlocksCall__Inputs {
    return new VerifyBlocksCall__Inputs(this);
  }

  get outputs(): VerifyBlocksCall__Outputs {
    return new VerifyBlocksCall__Outputs(this);
  }
}

export class VerifyBlocksCall__Inputs {
  _call: VerifyBlocksCall;

  constructor(call: VerifyBlocksCall) {
    this._call = call;
  }

  get _maxBlocksToVerify(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class VerifyBlocksCall__Outputs {
  _call: VerifyBlocksCall;

  constructor(call: VerifyBlocksCall) {
    this._call = call;
  }
}
