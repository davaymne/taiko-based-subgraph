// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class BlockL2 extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BlockL2 entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BlockL2 must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BlockL2", id.toString(), this);
    }
  }

  static loadInBlock(id: string): BlockL2 | null {
    return changetype<BlockL2 | null>(store.get_in_block("BlockL2", id));
  }

  static load(id: string): BlockL2 | null {
    return changetype<BlockL2 | null>(store.get("BlockL2", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get blockId(): BigInt {
    let value = this.get("blockId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockId(value: BigInt) {
    this.set("blockId", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt | null {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt | null) {
    if (!value) {
      this.unset("blockTimestamp");
    } else {
      this.set("blockTimestamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get blockHash(): Bytes | null {
    let value = this.get("blockHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set blockHash(value: Bytes | null) {
    if (!value) {
      this.unset("blockHash");
    } else {
      this.set("blockHash", Value.fromBytes(<Bytes>value));
    }
  }

  get status(): string | null {
    let value = this.get("status");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set status(value: string | null) {
    if (!value) {
      this.unset("status");
    } else {
      this.set("status", Value.fromString(<string>value));
    }
  }

  get proposed(): BlockProposedLoader {
    return new BlockProposedLoader(
      "BlockL2",
      this.get("id")!.toString(),
      "proposed",
    );
  }

  get verified(): BlockVerifiedLoader {
    return new BlockVerifiedLoader(
      "BlockL2",
      this.get("id")!.toString(),
      "verified",
    );
  }

  get proved(): TransitionProvedLoader {
    return new TransitionProvedLoader(
      "BlockL2",
      this.get("id")!.toString(),
      "proved",
    );
  }

  get contested(): TransitionContestedLoader {
    return new TransitionContestedLoader(
      "BlockL2",
      this.get("id")!.toString(),
      "contested",
    );
  }
}

export class Account extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Account must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Account", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Account | null {
    return changetype<Account | null>(store.get_in_block("Account", id));
  }

  static load(id: string): Account | null {
    return changetype<Account | null>(store.get("Account", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get prover(): ProverLoader {
    return new ProverLoader("Account", this.get("id")!.toString(), "prover");
  }

  get proposer(): ProposerLoader {
    return new ProposerLoader(
      "Account",
      this.get("id")!.toString(),
      "proposer",
    );
  }

  get contester(): ContesterLoader {
    return new ContesterLoader(
      "Account",
      this.get("id")!.toString(),
      "contester",
    );
  }

  get isProver(): boolean {
    let value = this.get("isProver");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isProver(value: boolean) {
    this.set("isProver", Value.fromBoolean(value));
  }

  get isProposer(): boolean {
    let value = this.get("isProposer");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isProposer(value: boolean) {
    this.set("isProposer", Value.fromBoolean(value));
  }

  get isContester(): boolean {
    let value = this.get("isContester");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isContester(value: boolean) {
    this.set("isContester", Value.fromBoolean(value));
  }
}

export class Prover extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Prover entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Prover must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Prover", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Prover | null {
    return changetype<Prover | null>(store.get_in_block("Prover", id));
  }

  static load(id: string): Prover | null {
    return changetype<Prover | null>(store.get("Prover", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): string {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get blockProved(): TransitionProvedLoader {
    return new TransitionProvedLoader(
      "Prover",
      this.get("id")!.toString(),
      "blockProved",
    );
  }

  get totalBlockProved(): i32 {
    let value = this.get("totalBlockProved");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalBlockProved(value: i32) {
    this.set("totalBlockProved", Value.fromI32(value));
  }
}

export class Proposer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Proposer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Proposer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Proposer", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Proposer | null {
    return changetype<Proposer | null>(store.get_in_block("Proposer", id));
  }

  static load(id: string): Proposer | null {
    return changetype<Proposer | null>(store.get("Proposer", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): string {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get blockProposed(): BlockProposedLoader {
    return new BlockProposedLoader(
      "Proposer",
      this.get("id")!.toString(),
      "blockProposed",
    );
  }

  get totalBlockProposed(): i32 {
    let value = this.get("totalBlockProposed");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalBlockProposed(value: i32) {
    this.set("totalBlockProposed", Value.fromI32(value));
  }
}

export class Contester extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Contester entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Contester must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Contester", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Contester | null {
    return changetype<Contester | null>(store.get_in_block("Contester", id));
  }

  static load(id: string): Contester | null {
    return changetype<Contester | null>(store.get("Contester", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): string {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get blockContested(): TransitionContestedLoader {
    return new TransitionContestedLoader(
      "Contester",
      this.get("id")!.toString(),
      "blockContested",
    );
  }

  get totalBlockContested(): i32 {
    let value = this.get("totalBlockContested");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set totalBlockContested(value: i32) {
    this.set("totalBlockContested", Value.fromI32(value));
  }
}

export class BlockProposed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BlockProposed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BlockProposed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BlockProposed", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BlockProposed | null {
    return changetype<BlockProposed | null>(
      store.get_in_block("BlockProposed", id.toHexString()),
    );
  }

  static load(id: Bytes): BlockProposed | null {
    return changetype<BlockProposed | null>(
      store.get("BlockProposed", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get proposerId(): Bytes {
    let value = this.get("proposerId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proposerId(value: Bytes) {
    this.set("proposerId", Value.fromBytes(value));
  }

  get proposer(): string {
    let value = this.get("proposer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposer(value: string) {
    this.set("proposer", Value.fromString(value));
  }

  get txGasPrice(): BigInt {
    let value = this.get("txGasPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasPrice(value: BigInt) {
    this.set("txGasPrice", Value.fromBigInt(value));
  }

  get txGasUsed(): BigInt {
    let value = this.get("txGasUsed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasUsed(value: BigInt) {
    this.set("txGasUsed", Value.fromBigInt(value));
  }

  get txFee(): BigInt {
    let value = this.get("txFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txFee(value: BigInt) {
    this.set("txFee", Value.fromBigInt(value));
  }

  get blockL2(): string {
    let value = this.get("blockL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set blockL2(value: string) {
    this.set("blockL2", Value.fromString(value));
  }

  get blockIdL2(): BigInt {
    let value = this.get("blockIdL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockIdL2(value: BigInt) {
    this.set("blockIdL2", Value.fromBigInt(value));
  }

  get assignedProver(): Bytes {
    let value = this.get("assignedProver");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set assignedProver(value: Bytes) {
    this.set("assignedProver", Value.fromBytes(value));
  }

  get livenessBond(): BigInt {
    let value = this.get("livenessBond");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set livenessBond(value: BigInt) {
    this.set("livenessBond", Value.fromBigInt(value));
  }

  get meta_l1Hash(): Bytes {
    let value = this.get("meta_l1Hash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set meta_l1Hash(value: Bytes) {
    this.set("meta_l1Hash", Value.fromBytes(value));
  }

  get meta_difficulty(): Bytes {
    let value = this.get("meta_difficulty");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set meta_difficulty(value: Bytes) {
    this.set("meta_difficulty", Value.fromBytes(value));
  }

  get meta_blobHash(): Bytes {
    let value = this.get("meta_blobHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set meta_blobHash(value: Bytes) {
    this.set("meta_blobHash", Value.fromBytes(value));
  }

  get meta_extraData(): Bytes {
    let value = this.get("meta_extraData");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set meta_extraData(value: Bytes) {
    this.set("meta_extraData", Value.fromBytes(value));
  }

  get meta_depositsHash(): Bytes {
    let value = this.get("meta_depositsHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set meta_depositsHash(value: Bytes) {
    this.set("meta_depositsHash", Value.fromBytes(value));
  }

  get meta_coinbase(): Bytes {
    let value = this.get("meta_coinbase");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set meta_coinbase(value: Bytes) {
    this.set("meta_coinbase", Value.fromBytes(value));
  }

  get meta_id(): BigInt {
    let value = this.get("meta_id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set meta_id(value: BigInt) {
    this.set("meta_id", Value.fromBigInt(value));
  }

  get meta_gasLimit(): BigInt {
    let value = this.get("meta_gasLimit");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set meta_gasLimit(value: BigInt) {
    this.set("meta_gasLimit", Value.fromBigInt(value));
  }

  get meta_timestamp(): BigInt {
    let value = this.get("meta_timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set meta_timestamp(value: BigInt) {
    this.set("meta_timestamp", Value.fromBigInt(value));
  }

  get meta_l1Height(): BigInt {
    let value = this.get("meta_l1Height");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set meta_l1Height(value: BigInt) {
    this.set("meta_l1Height", Value.fromBigInt(value));
  }

  get meta_txListByteOffset(): i32 {
    let value = this.get("meta_txListByteOffset");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set meta_txListByteOffset(value: i32) {
    this.set("meta_txListByteOffset", Value.fromI32(value));
  }

  get meta_txListByteSize(): i32 {
    let value = this.get("meta_txListByteSize");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set meta_txListByteSize(value: i32) {
    this.set("meta_txListByteSize", Value.fromI32(value));
  }

  get meta_minTier(): i32 {
    let value = this.get("meta_minTier");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set meta_minTier(value: i32) {
    this.set("meta_minTier", Value.fromI32(value));
  }

  get meta_blobUsed(): boolean {
    let value = this.get("meta_blobUsed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set meta_blobUsed(value: boolean) {
    this.set("meta_blobUsed", Value.fromBoolean(value));
  }

  get meta_parentMetaHash(): Bytes {
    let value = this.get("meta_parentMetaHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set meta_parentMetaHash(value: Bytes) {
    this.set("meta_parentMetaHash", Value.fromBytes(value));
  }

  get blockNumberL1(): BigInt {
    let value = this.get("blockNumberL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumberL1(value: BigInt) {
    this.set("blockNumberL1", Value.fromBigInt(value));
  }

  get blockTimestampL1(): BigInt {
    let value = this.get("blockTimestampL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestampL1(value: BigInt) {
    this.set("blockTimestampL1", Value.fromBigInt(value));
  }

  get transactionHashL1(): Bytes {
    let value = this.get("transactionHashL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHashL1(value: Bytes) {
    this.set("transactionHashL1", Value.fromBytes(value));
  }
}

export class TransitionContested extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TransitionContested entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TransitionContested must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TransitionContested", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): TransitionContested | null {
    return changetype<TransitionContested | null>(
      store.get_in_block("TransitionContested", id.toHexString()),
    );
  }

  static load(id: Bytes): TransitionContested | null {
    return changetype<TransitionContested | null>(
      store.get("TransitionContested", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get blockL2(): string {
    let value = this.get("blockL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set blockL2(value: string) {
    this.set("blockL2", Value.fromString(value));
  }

  get blockIdL2(): BigInt {
    let value = this.get("blockIdL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockIdL2(value: BigInt) {
    this.set("blockIdL2", Value.fromBigInt(value));
  }

  get tran_parentHash(): Bytes {
    let value = this.get("tran_parentHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_parentHash(value: Bytes) {
    this.set("tran_parentHash", Value.fromBytes(value));
  }

  get tran_blockHash(): Bytes {
    let value = this.get("tran_blockHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_blockHash(value: Bytes) {
    this.set("tran_blockHash", Value.fromBytes(value));
  }

  get tran_signalRoot(): Bytes {
    let value = this.get("tran_signalRoot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_signalRoot(value: Bytes) {
    this.set("tran_signalRoot", Value.fromBytes(value));
  }

  get tran_graffiti(): Bytes {
    let value = this.get("tran_graffiti");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_graffiti(value: Bytes) {
    this.set("tran_graffiti", Value.fromBytes(value));
  }

  get contesterId(): Bytes {
    let value = this.get("contesterId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contesterId(value: Bytes) {
    this.set("contesterId", Value.fromBytes(value));
  }

  get contester(): string {
    let value = this.get("contester");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set contester(value: string) {
    this.set("contester", Value.fromString(value));
  }

  get contestBond(): BigInt {
    let value = this.get("contestBond");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set contestBond(value: BigInt) {
    this.set("contestBond", Value.fromBigInt(value));
  }

  get tier(): i32 {
    let value = this.get("tier");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set tier(value: i32) {
    this.set("tier", Value.fromI32(value));
  }

  get blockNumberL1(): BigInt {
    let value = this.get("blockNumberL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumberL1(value: BigInt) {
    this.set("blockNumberL1", Value.fromBigInt(value));
  }

  get blockTimestampL1(): BigInt {
    let value = this.get("blockTimestampL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestampL1(value: BigInt) {
    this.set("blockTimestampL1", Value.fromBigInt(value));
  }

  get transactionHashL1(): Bytes {
    let value = this.get("transactionHashL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHashL1(value: Bytes) {
    this.set("transactionHashL1", Value.fromBytes(value));
  }

  get txGasPrice(): BigInt {
    let value = this.get("txGasPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasPrice(value: BigInt) {
    this.set("txGasPrice", Value.fromBigInt(value));
  }

  get txGasUsed(): BigInt {
    let value = this.get("txGasUsed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasUsed(value: BigInt) {
    this.set("txGasUsed", Value.fromBigInt(value));
  }

  get txFee(): BigInt {
    let value = this.get("txFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txFee(value: BigInt) {
    this.set("txFee", Value.fromBigInt(value));
  }
}

export class TransitionProved extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TransitionProved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type TransitionProved must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("TransitionProved", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): TransitionProved | null {
    return changetype<TransitionProved | null>(
      store.get_in_block("TransitionProved", id.toHexString()),
    );
  }

  static load(id: Bytes): TransitionProved | null {
    return changetype<TransitionProved | null>(
      store.get("TransitionProved", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get blockL2(): string {
    let value = this.get("blockL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set blockL2(value: string) {
    this.set("blockL2", Value.fromString(value));
  }

  get blockIdL2(): BigInt {
    let value = this.get("blockIdL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockIdL2(value: BigInt) {
    this.set("blockIdL2", Value.fromBigInt(value));
  }

  get tran_parentHash(): Bytes {
    let value = this.get("tran_parentHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_parentHash(value: Bytes) {
    this.set("tran_parentHash", Value.fromBytes(value));
  }

  get tran_blockHash(): Bytes {
    let value = this.get("tran_blockHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_blockHash(value: Bytes) {
    this.set("tran_blockHash", Value.fromBytes(value));
  }

  get tran_signalRoot(): Bytes {
    let value = this.get("tran_signalRoot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_signalRoot(value: Bytes) {
    this.set("tran_signalRoot", Value.fromBytes(value));
  }

  get tran_graffiti(): Bytes {
    let value = this.get("tran_graffiti");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tran_graffiti(value: Bytes) {
    this.set("tran_graffiti", Value.fromBytes(value));
  }

  get validityBond(): BigInt {
    let value = this.get("validityBond");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set validityBond(value: BigInt) {
    this.set("validityBond", Value.fromBigInt(value));
  }

  get tier(): i32 {
    let value = this.get("tier");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set tier(value: i32) {
    this.set("tier", Value.fromI32(value));
  }

  get blockNumberL1(): BigInt {
    let value = this.get("blockNumberL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumberL1(value: BigInt) {
    this.set("blockNumberL1", Value.fromBigInt(value));
  }

  get blockTimestampL1(): BigInt {
    let value = this.get("blockTimestampL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestampL1(value: BigInt) {
    this.set("blockTimestampL1", Value.fromBigInt(value));
  }

  get transactionHashL1(): Bytes {
    let value = this.get("transactionHashL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHashL1(value: Bytes) {
    this.set("transactionHashL1", Value.fromBytes(value));
  }

  get proverId(): Bytes {
    let value = this.get("proverId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proverId(value: Bytes) {
    this.set("proverId", Value.fromBytes(value));
  }

  get prover(): string {
    let value = this.get("prover");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set prover(value: string) {
    this.set("prover", Value.fromString(value));
  }

  get txGasPrice(): BigInt {
    let value = this.get("txGasPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasPrice(value: BigInt) {
    this.set("txGasPrice", Value.fromBigInt(value));
  }

  get txGasUsed(): BigInt {
    let value = this.get("txGasUsed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasUsed(value: BigInt) {
    this.set("txGasUsed", Value.fromBigInt(value));
  }

  get txFee(): BigInt {
    let value = this.get("txFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txFee(value: BigInt) {
    this.set("txFee", Value.fromBigInt(value));
  }
}

export class BlockVerified extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BlockVerified entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BlockVerified must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BlockVerified", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BlockVerified | null {
    return changetype<BlockVerified | null>(
      store.get_in_block("BlockVerified", id.toHexString()),
    );
  }

  static load(id: Bytes): BlockVerified | null {
    return changetype<BlockVerified | null>(
      store.get("BlockVerified", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get blockL2(): string {
    let value = this.get("blockL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set blockL2(value: string) {
    this.set("blockL2", Value.fromString(value));
  }

  get blockIdL2(): BigInt {
    let value = this.get("blockIdL2");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockIdL2(value: BigInt) {
    this.set("blockIdL2", Value.fromBigInt(value));
  }

  get assignedProver(): Bytes {
    let value = this.get("assignedProver");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set assignedProver(value: Bytes) {
    this.set("assignedProver", Value.fromBytes(value));
  }

  get prover(): Bytes {
    let value = this.get("prover");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set prover(value: Bytes) {
    this.set("prover", Value.fromBytes(value));
  }

  get blockHash(): Bytes {
    let value = this.get("blockHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set blockHash(value: Bytes) {
    this.set("blockHash", Value.fromBytes(value));
  }

  get statelRoot(): Bytes {
    let value = this.get("statelRoot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set statelRoot(value: Bytes) {
    this.set("statelRoot", Value.fromBytes(value));
  }

  get tier(): i32 {
    let value = this.get("tier");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set tier(value: i32) {
    this.set("tier", Value.fromI32(value));
  }

  get blockNumberL1(): BigInt {
    let value = this.get("blockNumberL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumberL1(value: BigInt) {
    this.set("blockNumberL1", Value.fromBigInt(value));
  }

  get blockTimestampL1(): BigInt {
    let value = this.get("blockTimestampL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestampL1(value: BigInt) {
    this.set("blockTimestampL1", Value.fromBigInt(value));
  }

  get transactionHashL1(): Bytes {
    let value = this.get("transactionHashL1");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHashL1(value: Bytes) {
    this.set("transactionHashL1", Value.fromBytes(value));
  }

  get txGasPrice(): BigInt {
    let value = this.get("txGasPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasPrice(value: BigInt) {
    this.set("txGasPrice", Value.fromBigInt(value));
  }

  get txGasUsed(): BigInt {
    let value = this.get("txGasUsed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txGasUsed(value: BigInt) {
    this.set("txGasUsed", Value.fromBigInt(value));
  }

  get txFee(): BigInt {
    let value = this.get("txFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set txFee(value: BigInt) {
    this.set("txFee", Value.fromBigInt(value));
  }
}

export class AdminChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AdminChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AdminChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AdminChanged", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AdminChanged | null {
    return changetype<AdminChanged | null>(
      store.get_in_block("AdminChanged", id.toHexString()),
    );
  }

  static load(id: Bytes): AdminChanged | null {
    return changetype<AdminChanged | null>(
      store.get("AdminChanged", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousAdmin(): Bytes {
    let value = this.get("previousAdmin");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set previousAdmin(value: Bytes) {
    this.set("previousAdmin", Value.fromBytes(value));
  }

  get newAdmin(): Bytes {
    let value = this.get("newAdmin");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newAdmin(value: Bytes) {
    this.set("newAdmin", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BeaconUpgraded extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BeaconUpgraded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BeaconUpgraded must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BeaconUpgraded", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BeaconUpgraded | null {
    return changetype<BeaconUpgraded | null>(
      store.get_in_block("BeaconUpgraded", id.toHexString()),
    );
  }

  static load(id: Bytes): BeaconUpgraded | null {
    return changetype<BeaconUpgraded | null>(
      store.get("BeaconUpgraded", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get beacon(): Bytes {
    let value = this.get("beacon");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set beacon(value: Bytes) {
    this.set("beacon", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Initialized extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Initialized entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Initialized must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Initialized", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Initialized | null {
    return changetype<Initialized | null>(
      store.get_in_block("Initialized", id.toHexString()),
    );
  }

  static load(id: Bytes): Initialized | null {
    return changetype<Initialized | null>(
      store.get("Initialized", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get version(): i32 {
    let value = this.get("version");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OwnershipTransferStarted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save OwnershipTransferStarted entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OwnershipTransferStarted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("OwnershipTransferStarted", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): OwnershipTransferStarted | null {
    return changetype<OwnershipTransferStarted | null>(
      store.get_in_block("OwnershipTransferStarted", id.toHexString()),
    );
  }

  static load(id: Bytes): OwnershipTransferStarted | null {
    return changetype<OwnershipTransferStarted | null>(
      store.get("OwnershipTransferStarted", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("OwnershipTransferred", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get_in_block("OwnershipTransferred", id.toHexString()),
    );
  }

  static load(id: Bytes): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Paused extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Paused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Paused must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Paused", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Paused | null {
    return changetype<Paused | null>(
      store.get_in_block("Paused", id.toHexString()),
    );
  }

  static load(id: Bytes): Paused | null {
    return changetype<Paused | null>(store.get("Paused", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ProvingPaused extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProvingPaused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ProvingPaused must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ProvingPaused", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ProvingPaused | null {
    return changetype<ProvingPaused | null>(
      store.get_in_block("ProvingPaused", id.toHexString()),
    );
  }

  static load(id: Bytes): ProvingPaused | null {
    return changetype<ProvingPaused | null>(
      store.get("ProvingPaused", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get paused(): boolean {
    let value = this.get("paused");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set paused(value: boolean) {
    this.set("paused", Value.fromBoolean(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class StateVariablesUpdated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save StateVariablesUpdated entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type StateVariablesUpdated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("StateVariablesUpdated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): StateVariablesUpdated | null {
    return changetype<StateVariablesUpdated | null>(
      store.get_in_block("StateVariablesUpdated", id.toHexString()),
    );
  }

  static load(id: Bytes): StateVariablesUpdated | null {
    return changetype<StateVariablesUpdated | null>(
      store.get("StateVariablesUpdated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get slotB_numBlocks(): BigInt {
    let value = this.get("slotB_numBlocks");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set slotB_numBlocks(value: BigInt) {
    this.set("slotB_numBlocks", Value.fromBigInt(value));
  }

  get slotB_lastVerifiedBlockId(): BigInt {
    let value = this.get("slotB_lastVerifiedBlockId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set slotB_lastVerifiedBlockId(value: BigInt) {
    this.set("slotB_lastVerifiedBlockId", Value.fromBigInt(value));
  }

  get slotB_provingPaused(): boolean {
    let value = this.get("slotB_provingPaused");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set slotB_provingPaused(value: boolean) {
    this.set("slotB_provingPaused", Value.fromBoolean(value));
  }

  get slotB___reservedB1(): i32 {
    let value = this.get("slotB___reservedB1");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set slotB___reservedB1(value: i32) {
    this.set("slotB___reservedB1", Value.fromI32(value));
  }

  get slotB___reservedB2(): i32 {
    let value = this.get("slotB___reservedB2");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set slotB___reservedB2(value: i32) {
    this.set("slotB___reservedB2", Value.fromI32(value));
  }

  get slotB___reservedB3(): BigInt {
    let value = this.get("slotB___reservedB3");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set slotB___reservedB3(value: BigInt) {
    this.set("slotB___reservedB3", Value.fromBigInt(value));
  }

  get slotB_lastUnpausedAt(): BigInt {
    let value = this.get("slotB_lastUnpausedAt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set slotB_lastUnpausedAt(value: BigInt) {
    this.set("slotB_lastUnpausedAt", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Unpaused extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Unpaused entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Unpaused must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Unpaused", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Unpaused | null {
    return changetype<Unpaused | null>(
      store.get_in_block("Unpaused", id.toHexString()),
    );
  }

  static load(id: Bytes): Unpaused | null {
    return changetype<Unpaused | null>(store.get("Unpaused", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Upgraded extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Upgraded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Upgraded must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Upgraded", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Upgraded | null {
    return changetype<Upgraded | null>(
      store.get_in_block("Upgraded", id.toHexString()),
    );
  }

  static load(id: Bytes): Upgraded | null {
    return changetype<Upgraded | null>(store.get("Upgraded", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get implementation(): Bytes {
    let value = this.get("implementation");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set implementation(value: Bytes) {
    this.set("implementation", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BlockProposedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BlockProposed[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BlockProposed[]>(value);
  }
}

export class BlockVerifiedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BlockVerified[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BlockVerified[]>(value);
  }
}

export class TransitionProvedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TransitionProved[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TransitionProved[]>(value);
  }
}

export class TransitionContestedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): TransitionContested[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<TransitionContested[]>(value);
  }
}

export class ProverLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Prover[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Prover[]>(value);
  }
}

export class ProposerLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Proposer[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Proposer[]>(value);
  }
}

export class ContesterLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Contester[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Contester[]>(value);
  }
}
